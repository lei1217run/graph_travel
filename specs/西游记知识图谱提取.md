# 西游记知识图谱提取

## 场景范围
- 以《西游记》为语料的 MVP 实施记录：章节切分→批量抽取→JSON 结果→对比评估接口。
- 本文件仅记录该场景的实现细节、迭代记录、代码映射与待办清单。

## 基准线规则（重要）
- 项目以知识图谱为核心，本文档是唯一基准线（Single Source of Truth）。
- 接口层（`compare_service.py`、`main.py`）仅为辅助与兼容用途，优先级最低。
- 任何方案、设计与改动均以本文档的规范为准；接口不得作为参考依据。
- 如遇不一致，一律以本文档为准，接口需跟随本文档调整。
- 评估与入库以 KG 架构、Prompt 模板与归一化规则为准；接口仅作为调用入口。

## 当前实现概览
- 章节切分脚本：`xiyou/split_chunks.py`
- 批量抽取脚本：`xiyou/batch_extractor.py`
- 对比评估服务：`xiyou/compare_service.py`，路由注册见 `main.py`
- 集中配置：`settings.yaml` 与 `xiyou/config.py`
 - 新增模块：`xiyou/normalize_adapter.py`（归一化适配器）、`xiyou/ingest_neo4j.py`（入库流程）

## 代码映射与关键行
- 章节切分：
  - 配置加载：`xiyou/split_chunks.py:7-12`
  - 路径常量：`xiyou/split_chunks.py:16-19`
  - 章节识别：`xiyou/split_chunks.py:23`，结束标记：`xiyou/split_chunks.py:25`
  - 清理策略：`xiyou/split_chunks.py:94-105`
  - 启动日志：`xiyou/split_chunks.py:108`
  - 主循环与保存：`xiyou/split_chunks.py:110-137`
- 批量抽取：
  - 配置加载与常量：`xiyou/batch_extractor.py:18-29`
  - 模板选择：`xiyou/batch_extractor.py:45-58`
  - Prompt 构建：`xiyou/batch_extractor.py:60-85`
  - 请求与解析：`xiyou/batch_extractor.py:86-116`
  - 文件枚举：`xiyou/batch_extractor.py:119-130`
  - 章节元信息：`xiyou/batch_extractor.py:171-178`
  - 日志扩展：`xiyou/batch_extractor.py:165-167`
  - 结果命名与跳过：`xiyou/batch_extractor.py:154-162`
- 对比评估：
  - 入口函数：`xiyou/compare_service.py:157`
  - 路由注册：`main.py:19-22`

## 配置要点
- 使用 `settings.yaml` 作为唯一源，集中管理：
  - `llm`：`api_key/base_url/model_name/system_prompt/stream/thinking`
  - `corpora`：`mode/default/base_dir/items{key:name/folder/raw_file}`
  - `run`：`limit_count/timeout_ms`
  - `naming`：`mode`（`NUMBERING`/`TITLE_PREFIXED`）
  - `prompts`：`selected/selection_mode/selectors/dynamic/templates[].variables(synonyms_map/alias_rules)`
  - 绝对路径转换：由 `resolve_paths` 在运行时按 `corpora.base_dir/items.folder` 计算
  - `results`：`use_model_suffix/overwrite/basename_template_id`
  - `relations`：`allowed/precedence/patterns/type_constraints/alias_relations`
  - `fusion`：`enabled/resolution_mode/group_by/key_format/confidence_merge/evidence_merge/conflict_resolution/chapter_strategy/keep_history`
  - `neo4j`：`uri/user/password`

### 执行流程与配置重点（手动模式）
- 前置配置检查
  - `llm`：确保 `api_key/base_url/model_name` 可用；如需流式或思考模式，设置 `stream/thinking`；`system_prompt` 明确仅输出严格 JSON。
  - `corpora`：确认 `default/items.<key>.folder/raw_file` 与 `base_dir` 一致；每本书使用独立目录结构 `raw/chapters/results`。
  - `prompts`：选择模板 `selected`（默认 `relations_plus`）；根据章节特性调整 `selection_mode` 与阈值；补齐 `synonyms_map`（如玉帝别名）与 `alias_rules`。
  - `relations`：闭集关系与优先级、触发模式、类型约束与 `alias_relations` 明确；避免模型输出超出闭集的关系名。
  - `fusion`：建议启用 `enabled:true`；采用 `group_by: head_tail`，代表章节 `chapter_strategy:first`，证据合并 `union`，置信度 `max`。
  - `results`：是否覆盖 `overwrite`、是否带模型后缀 `use_model_suffix`、基线模板归属 `basename_template_id`。
  - `neo4j`：确认图数据库连接可用；首次运行需创建约束与索引。
    - 下载/安装 Neo4j Desktop：[https://neo4j.com/download/](https://neo4j.com/download/)
    - 创建新数据库实例：`neo4j://localhost:7687`，默认密码 `neo4j`，首次登录后需修改。
    - 启用 HTTP 与 Bolt 端口：`dbms.connector.http.enabled=true`、`dbms.connector.bolt.enabled=true`。
    - 重启 Neo4j 服务：在 Neo4j Desktop 中点击数据库实例，选择 `Restart`。

- 手动执行关键动作（依次执行）
  - 切分原文（生成章节文本）：运行 `xiyou/split_chunks.py`，按 `corpora.default` 解析路径并输出到 `chapters_dir`。
  - 批量抽取（生成 JSON 结果）：运行 `xiyou/batch_extractor.py`，按模板构建 Prompt 调用 LLM，写入 `results_dir/result_%03d*.json`，携带 `meta`。
  - 预融合与入库（Neo4j）：运行 `xiyou/ingest_neo4j.py`，在书级聚合关系后执行“校准→融合”，写入融合关系（代表章节 + `qualifiers.chapters`），事件按章节写入。
  - 对比评估（可选）：启动接口后使用 `compare_service.py` 提供的路由进行章节/概览/批量对比。

- 使用建议与注意事项
  - 手动模式下，每步执行前均需核对 `settings.yaml` 的相关段落，避免路径或策略不一致导致产物不可用或相互覆盖。
  - 如需关闭融合以进行逐章对比或回滚，设置 `fusion.enabled=false`；写库将按章节逐条写入（不进行跨章节冲突解）。
  - 别名连通性依赖 `synonyms_map` 与 `alias_relations`：若发现同一实体的不同别名未连通，优先通过配置补齐词典与关键词集合。
  - 质量监控建议：记录一致性率、冲突率、覆盖率、过滤比例与每章有效记录数，并据此迭代 `relations.patterns/precedence/type_constraints` 与模板说明。

### 待扩展（接口触发）
- 规划接口入参触发执行动作：
  - `POST /pipeline/run`：参数包含 `book_key/steps{split,extract,ingest,compare}/prompts_override/fusion_override`，按入参执行流水线。
  - `GET /pipeline/status`：查询最近一次执行的统计与质量指标。
- 现阶段以手动脚本为主；后续将把上述手动步骤封装为接口触发，便于外部系统集成与自动化批处理。

### settings.yaml 建议片段（单书示例）
```yaml
llm:
  api_key: ${LLM_API_KEY}
  base_url: https://dashscope.aliyuncs.com/compatible-mode/v1
  model_name: qwen-plus

book_key: xiyouji
book_name: 西游记

corpora:
  mode: single
  default: xiyouji
  base_dir: data
  items:
    xiyouji:
      name: 西游记
      folder: 西游记
      raw_file: xiyouji.txt

run:
  limit_count: 3
  timeout_ms: 20000

naming:
  mode: TITLE_PREFIXED

results:
  use_model_suffix: false
  overwrite: false
  basename_template_id: relations_plus

prompts:
  selected: relations_plus
  selection_mode: static
  selectors:
    length_threshold: 8000
    dialogue_ratio_threshold: 0.50
  dynamic:
    override_to: events_relations
  templates:
    - id: relations_basic
      description: 仅抽取实体与核心关系
      scope: basic
      entity_types: [Person, Location, Item, Spell, Organization]
      relation_types: [师徒, 敌对, 位于, 持有, 使用]
      instructions: |
        仅输出 JSON 列表；严格遵循给定类型枚举；避免Markdown；若不确定请忽略。
      output_schema: relation_list
      max_tokens: 2048
      variables:
        language: zh
        book: xiyouji
        synonyms_map:
          行者: 孙悟空
          大圣: 孙悟空
          美猴王: 孙悟空
          玄奘: 唐僧
          唐三藏: 唐僧
          老君: 太上老君
        alias_rules:
          - strip:大圣
          - strip:行者
          - regex:(^“|”$)=

    - id: relations_plus
      description: 扩展关系范围并输出证据与置信度
      scope: plus
      entity_types: [Person, Location, Item, Spell, Organization, Deity]
      relation_types: [师徒, 敌对, 位于, 持有, 使用, 亲属, 隶属, 封号]
      instructions: |
        输出 JSON；每条关系包含 evidence(原文片段) 与 confidence(0-1)。避免Markdown；若不确定请忽略。
      output_schema: relation_with_meta
      max_tokens: 3072
      variables:
        language: zh
        book: xiyouji
        synonyms_map:
          行者: 孙悟空
          大圣: 孙悟空
          美猴王: 孙悟空
          玄奘: 唐僧
          唐三藏: 唐僧
          老君: 太上老君
        alias_rules:
          - strip:大圣
          - strip:行者
          - regex:(^“|”$)=

    - id: events_relations
      description: 同时抽取事件与关系
      scope: events
      entity_types: [Person, Location, Item, Spell, Organization]
      relation_types: [师徒, 敌对, 位于, 持有, 使用]
      instructions: |
        先抽取事件(类型、时间、地点、参与者角色)，再抽取关系；统一 JSON 输出；避免Markdown。
      output_schema: event_plus_relation
      max_tokens: 4096
      variables:
        language: zh
        book: xiyouji
        synonyms_map:
          行者: 孙悟空
          大圣: 孙悟空
          美猴王: 孙悟空
          玄奘: 唐僧
          唐三藏: 唐僧
          老君: 太上老君
        alias_rules:
          - strip:大圣
          - strip:行者
          - regex:(^“|”$)=
```

### settings.yaml 建议片段（批量示例）
```yaml
corpora:
  mode: batch
  base_dir: data
  include: [xiyouji]
  items:
    xiyouji:
      name: 西游记
      folder: 西游记
      raw_file: xiyouji.txt
```
```python
import os
def resolve_paths(base_dir: str, book_key: str):
    raw_dir = os.path.join(base_dir, "raw", book_key)
    chapters_dir = os.path.join(base_dir, "chapters", book_key)
    results_dir = os.path.join(base_dir, "results", book_key)
    raw_file = os.path.join(raw_dir, f"{book_key}.txt")
    return {"raw_dir": raw_dir, "chapters_dir": chapters_dir, "results_dir": results_dir, "raw_file": raw_file}
```
注：路径由 `resolve_paths` 基于 `corpora` 生成，确保每本书独立目录与结果隔离。

## Schema 字段定义与兼容性
- 实体：`id/name/type/aliases/attributes?/evidence?/source_chapters?`
- 关系：`head/head_type/relation/tail/tail_type/confidence?/evidence?/qualifiers?`
- 事件：`event_type/time?/location?/participants{Agent/Patient/Instrument/Beneficiary}?/evidence?/confidence?`
- 兼容策略：`confidence/evidence` 可为空以适配不同模板；跨章节别名合并保留 `canonical_name`（由 `synonyms_map/alias_rules` 归一）。

## 日志字段与计量口径
- 补充字段建议：`request_id/retry_count`（用于跨次追踪与重试计数）
- 计量口径：`records_count = relations_count + events_count`（分项与总计均应记录）；接口侧已分别统计，日志建议加入总计摘要。

## 多语料 Book 规范化
- 目录采用 `corpora.items.<key>.folder`（如 `西游记`），展示使用 `corpora.items.<key>.name`（如 `西游记`）。
- `key` 统一作为 `book_key` 使用，文件名默认 `f"{key}.txt"`，可由 `raw_file` 覆盖。
- 保持“中文目录 + 拼音键”的组合，便于展示与代码一致性。

### 多语料路径解析与批量选择（规范）
- 模式：`corpora.mode: single | batch`
- 单书模式（默认）：使用 `corpora.default` 指定一本书；按模板生成路径。
- 批量模式：按 `corpora.include` 指定书目集合；为空则使用 `corpora.items` 的键集合。
- 路径模板（统一生成）：
  - `raw_dir   = {base_dir}/raw/{book_key}`
  - `chapters  = {base_dir}/chapters/{book_key}`
  - `results   = {base_dir}/results/{book_key}`
  - `raw_file  = {raw_dir}/{book_key}.txt`
- 绝对路径转换由 `resolve_paths` 统一处理。
- 兼容策略：若未配置 `targets`，继续使用现有 `paths.*`；批量模式下优先采用模板生成的路径。

#### 旧配置示例（保留于文档，不再使用）
```yaml
book_key: xiyouji
book_name: 西游记
paths:
  raw_dir: data/西游记
  chapters_dir: data/西游记
  results_dir: data/西游记/results
targets:
  mode: batch
  include: [xiyouji, sanguo]
books:
  xiyouji:
    name: 西游记
    folder: 西游记
  sanguo:
    name: 三国演义
    folder: 三国演义
```

说明：上述旧配置已在 v10 起被移除，代码仅支持 `corpora.*`。

## 迁移指南
- 背景：为统一与简化多语料配置，v10 起移除旧字段（`book_key/book_name/paths/targets/books`），全面采用 `corpora`。
- 字段映射：
  - `book_key/book_name` → `corpora.default` 与 `corpora.items.<key>.name`
  - `paths.base_dir/raw_dir/chapters_dir/results_dir` → `corpora.base_dir` + `corpora.items.<key>.folder`（结果固定在 `folder/results`）
  - `targets.mode/include` 与 `books` → `corpora.mode/include/items`
  - 原文文件名 → `corpora.items.<key>.raw_file`（缺省 `f"{key}.txt"`）
- 旧配置示例（仅文档保留）：
```yaml
book_key: xiyouji
book_name: 西游记
paths:
  raw_dir: data/西游记
  chapters_dir: data/西游记
  results_dir: data/西游记/results
targets:
  mode: batch
  include: [xiyouji, sanguo]
books:
  xiyouji:
    name: 西游记
    folder: 西游记
  sanguo:
    name: 三国演义
    folder: 三国演义
```
- 新配置对等示例：
```yaml
corpora:
  mode: batch
  base_dir: data
  include: [xiyouji, sanguo]
  items:
    xiyouji:
      name: 西游记
      folder: 西游记
      raw_file: xiyouji.txt
    sanguo:
      name: 三国演义
      folder: 三国演义
      raw_file: sanguo.txt
```
- 影响范围：
  - 路径解析：`xiyou/config.py:116-124`（`resolve_paths`）
  - 目标书目解析：`xiyou/config.py:136-145`（`list_target_books`）
  - 切分入口：`xiyou/split_chunks.py:144-151`（按 `corpora.mode` 执行）
  - 抽取入口：`xiyou/batch_extractor.py:196-205`（按书遍历并写入 `meta`）
  - 对比入口：`xiyou/compare_service.py:157/239-241/275-279`（按书解析结果目录）
  - 路由扩展：`main.py:32-37/39-41`（多书概览与批量）

#### 自动发现（批量模式）
- 当 `corpora.include` 为空时，默认使用 `corpora.items` 的键集合；如需目录扫描可在后续版本加入扩展。
- 如需自定义原文文件名，可在 `items.<key>.raw_file` 指定，默认 `f"{key}.txt"`。

#### 执行流程示例
- 单书模式（`targets.mode: single`）
  - 解析 `book_key` 与 `base_dir`
  - 生成路径：`raw/chapters/results` 与 `raw_file`
  - 执行章节切分（输入：`raw_file`，输出：`chapters_dir`）
  - 执行批量抽取（输入：`chapters_dir`，输出：`results_dir`）
  - 执行概览与对比评估（输入：`results_dir`）
  - 可选：入库 Neo4j（输入：`results_dir`，按 `relations/events`）
- 批量模式（`targets.mode: batch`）
  - 解析目标书目集：`targets.include` 或自动发现 `raw/*`
  - 逐书运行上述流程并聚合统计（每本书独立的 `chapters/results`）
- 控制项：
  - 模板选择：`prompts.selection_mode`（`static`/`dynamic`）与阈值
  - 结果覆写：`results.overwrite: true/false`
  - 模型后缀：`results.use_model_suffix: true/false`

```python
# 伪代码示例（仅说明流程，不执行）
books = list_target_books(cfg)  # single/batch 模式解析目标书目
for key in books:
    paths = resolve_paths(cfg['paths']['base_dir'], key)
    split_chapters(paths['raw_file'], paths['chapters_dir'])
    extract_relations(paths['chapters_dir'], paths['results_dir'], cfg['prompts'], cfg['results'])
    compare_overview(key)
    # 可选：
    # ingest_neo4j(paths['results_dir'], cfg['neo4j'])
```

## Prompt 保留变量（未用项）
- `output_schema`：用于提示模型遵循结构化字段输出，提升稳定性。
- `max_tokens`：用于控制输出容量提示，防止过长回答；可与模型上下文长度联动。
- 建议在 Prompt 头部加入这些保留变量说明，保持模板间行为一致性。

## Alias 归一策略与样例
- 归一顺序：`regex_rules` → `synonyms_map` → `strip_tokens`。
- 规则格式（在模板 `variables.alias_rules` 中定义）：
  - `strip:<token>`：移除名称头尾指定标记，例如 `strip:大圣`、`strip:行者`。
  - `regex:<pattern>=<replace>`：进行正则替换，例如 `regex:(^“|”$)=` 去除引号，`regex:\s+= ` 归一空白。
- 代码位置：归一函数 `xiyou/compare_service.py:44-66`（规则收集与应用）。
- 示例（不落盘，仅示意）：
  - `alias_rules: ["strip:大圣", "strip:行者", "regex:(^“|”$)=", "regex:\\s+= "]`
  - 效果：`“孙悟空”`→`孙悟空`；`大圣孙悟空`→`孙悟空`；`行者 孙悟空`→`孙悟空`

## 路径生成以 book_key 为准
- 切分入口根据 `book_key` 生成原文路径：`xiyou/split_chunks.py:16-18`。
- 规则：`RAW_FILE_PATH = paths.raw_dir / f"{book_key}.txt"`；结果与章节目录仍读取配置的绝对路径。

## Prompt 管理与构建
- 多模板集中：`settings.yaml.prompts.templates`
- 动态选择：长度阈值与对话比例触发，默认 `relations_plus`，触发切换为 `events_relations`（`xiyou/batch_extractor.py:62-71`）
- 模板变量注入：语言、语料、同义词与别名规则（`xiyou/batch_extractor.py:74-95`）

## 统一归一化输出结构（规范）
- 归一目标：将不同模板输出统一为 `{"entities","relations","events","meta"}` 用于评估与入库。
- 模板映射：
  - `relations_plus`：输入键为 `relation_with_meta`（列表）；映射字段 `type→relation`，缺失的 `head_type/tail_type` 统一回退为 `Unknown`。
  - `events_relations`：
    - 关系：支持 `subject/object` 与 `head/tail` 两种字段名；统一为 `head/tail/relation`。
    - 事件：输入键 `event_plus_relation` 或 `events`；`participants` 列表统一折叠为字典 `role→[entity]`。
    - 实体：如存在 `entities` 列表，作为实体提示参与去重；否则由关系列表派生。
  - `relations_basic`：输入为关系列表，仅含核心字段；类型缺失统一回退为 `Unknown`。
- 别名归一顺序：`regex_rules` → `synonyms_map` → `strip_tokens`。
  - 规则格式：
    - `strip:<token>`
    - `regex:<pattern>=<replace>`
- 噪声过滤：当 `head/tail` 等于类型枚举（`Person/Location/Item/Spell/Organization/Deity`）时视为噪声，跳过。
 - 基准规则：
  - “同义词”关系转储为 `ALIAS` 类型边；`head` 保留原始名称（仅做正则清洗），`tail` 归一到规范名。若归一后两端相同则跳过该边。
  - 统一关系类型策略：图数据库中使用单一关系标签 `RELATION`，关系名称存放在属性 `type`，避免动态关系标签带来的索引与维护成本。

```python
def normalize_output(raw, tpl_id, synonyms_map, alias_rules):
    # 返回结构：{"entities": [...], "relations": [...], "events": [...], "meta": {...}}
    # 关键策略：将 relation=="同义词" 转换为 relation=="ALIAS"；
    #  - ALIAS 边的 head 保留原始名称（仅正则清洗），tail 归一到规范名；若两端归一后相同则跳过该边
    #  - 类型缺失回退 Unknown；参与者统一为 role→[name]
    ...
```

## Neo4j 入库伪代码（规范）
- 节点与关系模型：
  - 节点 `Entity {name, type}`（唯一键 `(name,type)`）
  - 节点 `Event {event_type, book, chapter, time?, location?, evidence?, confidence?, participants}`（唯一键 `(event_type,book,chapter)`）
  - 关系 `(:Entity)-[:RELATION {type, confidence?, evidence?, qualifiers?, book, chapter}]->(:Entity)`（统一使用 `RELATION`，关系名置于属性 `type`）
- 唯一约束与索引（Cypher）：
  - `CREATE CONSTRAINT entity_unique IF NOT EXISTS FOR (e:Entity) REQUIRE (e.name, e.type) IS UNIQUE;`
  - `CREATE CONSTRAINT event_unique IF NOT EXISTS FOR (e:Event) REQUIRE (e.event_type, e.book, e.chapter) IS UNIQUE;`
  - `CREATE INDEX relation_type IF NOT EXISTS FOR ()-[r:RELATION]-() ON (r.type);`
- 执行流程：
  - 发现书目：按 `corpora.mode/include/items`。
  - 遍历 `results_dir` 下的 `*.json`，读取 `meta` 获取 `template_id/book_key/chapter_id`。
  - 根据模板变量 `synonyms_map/alias_rules` 执行归一化，得到统一结构。
  - 使用 `MERGE` 幂等写入节点与关系；事件参与者保存在 `participants` 属性中（如需角色边可后续增量派生）。

```python
def neo4j_upsert(driver, kg, book_key, chapter_id):
    with driver.session() as s:
        for ent in kg.get("entities", []):
            s.run("MERGE (e:Entity {name:$name,type:$type})", name=ent["name"], type=ent["type"]) 
        for rel in kg.get("relations", []):
            rt = rel.get("relation")
            if rt == "同义词":
                rt = "ALIAS"
            # 若 head 与 tail 在归一后相同，可选择跳过；此处示例直接写入前已在归一阶段过滤
            s.run(
                "MATCH (h:Entity {name:$h, type:$ht}) MATCH (t:Entity {name:$t, type:$tt}) "
                "MERGE (h)-[r:RELATION {type:$rt, book:$bk, chapter:$cid}]->(t) "
                "SET r.confidence=$conf, r.evidence=$ev, r.qualifiers=$ql",
                h=rel["head"], ht=rel["head_type"], t=rel["tail"], tt=rel["tail_type"],
                rt=rt, bk=book_key, cid=chapter_id,
                conf=rel.get("confidence"), ev=rel.get("evidence"), ql=rel.get("qualifiers") or {}
            )
        for evt in kg.get("events", []):
            s.run(
                "MERGE (e:Event {event_type:$et, book:$bk, chapter:$cid}) "
                "SET e.time=$tm, e.location=$loc, e.evidence=$ev, e.confidence=$conf, e.participants=$parts",
                et=evt.get("event_type"), bk=book_key, cid=chapter_id,
                tm=evt.get("time"), loc=evt.get("location"), ev=evt.get("evidence"),
                conf=evt.get("confidence"), parts=evt.get("participants") or {}
            )
```

## 关系本体与融合（配置驱动）
- 目标：以配置化的闭集标签、触发模式与融合策略，提升跨章节一致性与可解释性，同时尽量不改动现有写库逻辑。
- 原则：本体闭集与优先级在 `settings.yaml` 管理；允许单句证据拆分为多条关系输出；类型约束用于过滤不合理组合；融合在写库之前完成。

### settings.yaml 新增建议（关系与融合）
```yaml
version: 1
relations:
  allowed: [师徒, 位于, 使用, 持有, 敌对, 别名, 姓氏, 法名, 封号, 本体, 源于, 亲属, 隶属]
  precedence: [姓氏, 法名, 封号, 别名]
  patterns:
    - relation: 姓氏
      include: ["姓", "其姓为", "复姓"]
      exclude: []
    - relation: 法名
      include: ["法名", "起法名", "赐法名"]
      exclude: []
    - relation: 封号
      include: ["封", "赐", "授", "册封", "加封"]
      exclude: []
    - relation: 别名
      include: ["又名", "别名", "称作", "称为", "自称"]
      exclude: []
  type_constraints:
    姓氏: ["Person-Text"]
    法名: ["Person-Text"]
    封号: ["Person-Title"]
fusion:
  enabled: true
  resolution_mode: pre_ingest
  key_format: "{head}|{tail}|{relation}"
  confidence_merge: max
  evidence_merge: union
  conflict_resolution: precedence
  keep_history: true
```

### Prompt 优化规范
- 闭集选择：明确 `relations.allowed`，模型必须从闭集标签中选择。
- 多输出指令：当一证据同时支持多个关系，分别输出多条记录，不进行二选一覆盖。
- 触发词标注：要求在输出中保留支撑片段与触发词类别，便于校准与审计。
- 类型约束提醒：提示模板中说明不合理的实体类型组合将降置信或过滤。
- 跨章节一致性：若已有高置信历史事实，除非出现强触发反证，不变更标签。

### 数据流调整（最小改动）
- 路线 A（推荐）：在读取章节 JSON 后，于内存执行“校准→验证→融合”，产出规范化的关系列表，再交给现有 `ingest_neo4j` 写库。
- 路线 B：首次全量预融合生成基线事实，后续新增章节仅做增量融合，入口仍使用现有写库；需将 `ingest_neo4j` 支持批次输入。
- 路线 C：库内融合与审计，关系属性保留 `sources/confidence_history/canonical` 并周期任务融合；改动较大，后续阶段评估。

### 与 ingest_neo4j 的关系
- 采用路线 A 时，写库的 Cypher 结构与 MERGE 策略不变，仅更换写库前的输入来源为“融合后的规范数据”。
- 如需保留来源审计，可在关系属性中附加 `book/chapter/evidence/confidence` 的聚合；保持 `RELATION.type` 作为关系名属性，避免动态关系标签。

### 质量度量与回路
- 指标：一致性率、冲突率、覆盖率、被过滤比例、每章有效记录数。
- 回路：用上述指标指导 `relations.patterns/precedence/type_constraints` 的迭代；必要时调整 Prompt 模板的说明与示例。

### 路线 A 落地计划（预融合适配器）
- 目标：在不改动 Neo4j 写库核心逻辑的前提下，采用“校准→验证→融合”的预处理，将融合后的规范数据喂给现有 `ingest_neo4j`。
- 配置：在 `settings.yaml` 增加 `relations.allowed/precedence/patterns/type_constraints` 与 `fusion.*` 段，作为唯一策略来源。
- 数据流：读取章节 JSON → 校准（闭集与触发模式）→ 验证（类型约束与冲突过滤）→ 融合（跨章节合并、证据/置信度聚合）→ 交付写库。
- 写库：保持 `RELATION.type` 作为关系名属性与现有 MERGE 操作不变；如需审计，在关系属性聚合 `book/chapter/evidence/confidence`。
- 指标：上线后按“一致性率、冲突率、覆盖率、过滤比例、每章有效记录数”进行监控与策略迭代。
- 回滚：如融合策略引入噪声，切换 `fusion.enabled=false` 即可恢复按章节独立写入。

## 结果命名与保留
- 基线模板文件名归属：由 `results.basename_template_id` 决定（默认 `relations_plus`），写入 `result_%03d.json`
- 其他模板：`result_%03d__tpl-<template_id>.json`
- 可选模型维度：`__model-<model_name>`
- 跳过判断按目标文件名进行，不清理其他模板历史（`xiyou/batch_extractor.py:151-158`）
- 覆盖开关：`results.overwrite: true/false`；为 `true` 时即使目标文件存在也重新生成（日志事件 `overwrite`）（`xiyou/batch_extractor.py:151-158`）
 - 命名归属不受 `prompts.selected` 影响；切换选择模板不会改变基线文件名归属，避免跨次覆盖与混淆。
 - 建议：如需变更基线模板，需显式修改 `results.basename_template_id` 并在变更窗口进行一次性迁移或确保不覆盖历史产物。

## 日志字段与示例
- 统一补充：`template_id/model_name/chapter_id/chapter_title/duration_ms/records_count`
- 关键事件：`extract.start/template_selected/saved/fail`（`xiyou/batch_extractor.py:156-159/166-168`）

## 对比评估接口
- 单章对比：`GET /compare/chapter`（`main.py:19-22`）
- 概览统计：`GET /compare/overview`（`main.py:24-26`）
- 批量对比：`POST /compare/batch`（`main.py:28-30`）
- 多书概览：`GET /compare/overview_multi`（`main.py:32-37`）
- 多书批量：`POST /compare/batch_books`（`main.py:39-41`）
- 输入参数：`book/chapter_id/templates/model_name?/confidence_min/include_events`
- 多书输入：`books/chapter_ids?/chapter_range?/templates/model_name?/confidence_min/include_events`
- 输出结构：`meta/metrics/diffs/samples`；批量接口返回 `summary/per_chapter`
- 多书批量输出：`summary_total/per_book` 聚合各书的计数
- 文件定位：默认模板 `result_XXX.json`；指定模板 `result_XXX__tpl-<template_id>.json`；模型后缀可选 `__model-<model_name>`
 - 文件后缀兼容：启用 `results.use_model_suffix` 时，读取端自动兼容无后缀与模型后缀两种命名（默认模板与非默认模板均适配），无需在请求显式传 `model_name`。代码位置：`xiyou/compare_service.py:102-112/183-189/275-283`

## 迭代记录（摘要）
- 修复相对导入与路径为绝对路径，兼容脚本与包运行（`xiyou/config.py`）
- 集成 YAML 配置与 Prompt 多模板，支持变量注入与动态选择（`xiyou/batch_extractor.py`）
- 扩展结构化日志，补充 `model_name` 与 `chapter_title`（`xiyou/batch_extractor.py`）
- 实施结果命名后缀策略，避免不同模板互相覆盖（`xiyou/batch_extractor.py`）
- 封装章节级对比服务并注册接口（`xiyou/compare_service.py`、`main.py`）

## 迭代日志
- 2025-11-26 v1
  - 写入结果 `meta` 字段：`book/chapter_id/chapter_title/model_name/template_id/timestamp`（`xiyou/batch_extractor.py:160-167` 附近）
  - 新增对比接口：`GET /compare/overview` 与 `POST /compare/batch`（`xiyou/compare_service.py:190-237`、`main.py:22-28`）
  - 统一结果结构：当模型返回关系列表时，保存为 `{"relations": [...], "meta": {...}}`
- 2025-11-26 v2
  - 修订场景文档边界，新增“项目概述.md”与场景专用文档
  - 记录代码映射与关键行，明确日志与命名策略
- 2025-11-26 v3
  - 补充 Schema 字段定义与兼容策略（场景文档）
  - 明确日志计量口径与补充字段建议：`request_id/retry_count`（待实现）
  - 增加多语料 `book_key/book_name` 规范与 Prompt 保留变量说明
- 2025-11-26 v4
  - 结果 `meta` 包含 `book_key/book_name`，日志 `saved` 输出 `relations_count/events_count/records_total` 与 `request_id`
  - 保存文件名支持模型后缀开关 `results.use_model_suffix`（默认关闭）（`xiyou/batch_extractor.py:162-165`）
  - Prompt 头部注入 `output_schema/max_tokens`（`xiyou/batch_extractor.py:74-95`）
- 2025-11-26 v5
  - 在 `settings.yaml` 增加 `book_key/book_name` 与 `results.use_model_suffix`，并将 `alias_rules` 规范为 `strip:/regex:` 格式
  - 切分原文路径改为以 `book_key` 生成：`xiyou/split_chunks.py:16-18`
  - 对比服务归一策略支持 `alias_rules`：`xiyou/compare_service.py:44-66`、解析调用处更新
- 2025-11-26 v6
  - 修复抽取耗时计算：在请求前设置 `t0` 并在保存后计算 `duration_ms`（`xiyou/batch_extractor.py:169-186`）
  - 统一模板选择：将已选模板 `tpl` 传入 `extract_chapter`，避免函数内部二次选择（`xiyou/batch_extractor.py:101-116/169-170`）
  - 增加请求超时控制与 JSON 解析降级（`timeout=TIMEOUT_MS/1000` 与括号截断解析）（`xiyou/batch_extractor.py:105-116`）
  - 移除未使用的 `generate_prompt`（`xiyou/batch_extractor.py:40-56`）
- 2025-11-26 v7
  - 修复配置解析优先级：环境变量优先于占位符字符串 `${...}`，支持 `LLM_API_KEY/NEO4J_PASSWORD` 等敏感信息覆盖（`xiyou/config.py:53-71`）
  - 占位符缺失时返回空值以触发“缺少LLM配置”，避免将 `${LLM_API_KEY}` 误传入客户端
- 2025-11-26 v8
  - 增加多语料路径解析与书目选择：`resolve_paths`（`xiyou/config.py:116`）、`list_target_books`（`xiyou/config.py:136`）
  - 改造章节切分支持批量模式：入口按 `targets.mode` 切换并逐书执行（`xiyou/split_chunks.py:144-151`）
  - 改造批量抽取支持批量模式与模板变量按书注入：`process_book`（`xiyou/batch_extractor.py:132`）与入口切换（`xiyou/batch_extractor.py:196-205`）
  - 更新配置：新增 `paths.base_dir`（`settings.yaml:8`）、`targets.mode`（`settings.yaml:99-100`）与 `books.xiyouji`（`settings.yaml:102-104`）
- 2025-11-26 v9
  - 对比服务路径适配为按书解析：`compare_chapter/overview/batch` 使用 `resolve_paths`（`xiyou/compare_service.py:157-161/237-241/275-279`）
  - 新增多书接口：`compare_overview_multi/compare_batch_books`（`xiyou/compare_service.py:313-335`），并在 `main.py` 注册（`main.py:32-41`）
- 2025-11-27 v10
  - 全面启用 `corpora` 配置方案，移除旧字段 `book_key/book_name/paths/targets/books`
  - 更新解析：`resolve_paths/list_target_books` 仅读取 `corpora.*`
  - 更新脚本：`split_chunks.py` 与 `batch_extractor.py` 使用 `corpora.default/mode/items`
  - 保留旧配置示例于文档作为参考，不再在代码中支持

- 2025-11-27 v11
  - 采用稳定命名方案（方案 B）：新增 `results.basename_template_id`，默认 `relations_plus`
  - 解耦“默认选择模板”与“基线文件名归属”，避免因切换 `prompts.selected` 覆盖 `result_%03d.json`
  - 明确命名规则：基线模板写入 `result_%03d.json`，其他模板写入 `result_%03d__tpl-<template_id>.json`，模型后缀可选 `__model-<model_name>`

- 2025-11-27 v12
  - 新增归一化与入库模块：`xiyou/normalize_adapter.py`、`xiyou/ingest_neo4j.py`
  - 归一规则落实：别名归一顺序、ALIAS 转储、类型缺失回退、参与者结构统一
  - 入库模型落实：统一 `RELATION` 标签、节点与约束、批量幂等写入

- 2025-11-27 v13
  - 适配 `settings.yaml` 与现有 `results` 结构：`relation_with_meta/event_plus_relation`
  - 修复归一化逻辑：默认不依赖 `head_type/tail_type` 字段，统一回退为 `Unknown`（`xiyou/normalize_adapter.py:100-105`）
  - 支持将 `别名/同义词` 统一转储为 `ALIAS`，并依据 `synonyms_map` 自动判别方向为 `别名→规范名`（`xiyou/normalize_adapter.py:80-89`）
- 过滤类型枚举噪声：当 `head/tail` 等于类型枚举时跳过（`Person/Location/Item/Spell/Organization/Deity`），与样例 `tail:"Organization"` 对齐（`xiyou/normalize_adapter.py:97-99`）
- 入库属性类型修正：复杂 Map 改为 JSON 字符串存储（`qualifiers_json/participants_json`），避免 Neo4j 类型错误（`xiyou/ingest_neo4j.py:33-38/43-49`）

- 2025-11-27 v14
  - 移除规范输出中的 `head_type/tail_type` 字段，避免与模板输出不一致且无实际意义（统一以实体名为唯一键）
  - 入库节点唯一性改为按 `name`（新增 `entity_name_unique` 约束），关系匹配仅按 `name`（`xiyou/ingest_neo4j.py:21-26/33-41`）
  - 实体集合去重逻辑改为仅基于名称（`xiyou/normalize_adapter.py:90-98`）

- 2025-11-27 v15
  - 选定“路线 A（预融合适配器）”为实施方案：在写库前完成校准、验证与跨章节融合，写库逻辑与关系模型保持不变。
  - 文档新增“关系本体与融合（配置驱动）”与“路线 A 落地计划”章节，收敛到 `settings.yaml` 配置驱动，避免代码硬编码。
  - 明确度量指标与回滚开关（`fusion.enabled`），为后续代码落地与评估提供依据。

- 2025-11-27 v16
  - 新增校准与融合实现：`calibrate_relations`（`xiyou/normalize_adapter.py:159-180`）、`fuse_relations`（`xiyou/normalize_adapter.py:182-218`）。
  - 更新入库流程：书级聚合并融合关系，事件按章节写入；新增 `neo4j_upsert_events`（`xiyou/ingest_neo4j.py:51-60`），改造 `ingest_results` 实现书级融合（`xiyou/ingest_neo4j.py:62-110`）。
  - 写库保持 `RELATION.type` 属性模型不变，融合后的证据采用 `union` 合并并写入 `evidence`，置信度采用 `max`。

- 2025-11-27 v17
  - 同步 `settings.yaml`：新增 `relations.allowed/precedence/patterns/type_constraints` 与 `fusion.*` 段作为策略来源，避免硬编码。
  - 触发模式示例：为 `姓氏/法名/封号/别名` 增加 `include/exclude`，便于校准层识别并拆分多关系输出。
  - 回滚与开关：使用 `fusion.enabled` 控制融合开关，后续迭代将按监控指标优化策略。

- 2025-11-27 v18
  - 修正融合策略：按 `head-tail` 分组选择唯一关系，冲突用 `relations.precedence` + `confidence=max` 解决；不再并存冲突标签。
  - 章节属性：取消硬编码 `FUSED`，关系级写入使用 `chapter_strategy:first` 选择代表章节，并在 `qualifiers_json` 中保留 `chapters` 列表。
  - 清理无用变量：移除 `ingest_neo4j.py:90-92` 的未使用中间变量；关系写库使用 `rel.chapter_id` 覆盖 `chapter` 字段。

- 2025-11-27 v19
  - 优化 LLM 调用：支持 `stream` 与思考模式 `thinking`（`settings.yaml.llm.*`），参数化 `system_prompt`，避免与模板指令冲突（`xiyou/batch_extractor.py:20-23/88-118`）。
  - 增强 Prompt 构建：注入闭集关系与优先级、明确多关系拆分与触发词标注要求（`xiyou/batch_extractor.py:62-86`）。
  - 配置同步：`settings.yaml.llm.system_prompt/stream/thinking` 新增；保留默认关闭，按需开启。

- 2025-11-27 v20
  - 别名识别配置化：在 `settings.yaml.relations.alias_relations` 配置别名关键词集合，消除代码硬编码。
  - 统一别名关系：归一层将 `alias_relations` 中的关系统一写入为 `ALIAS`（`xiyou/normalize_adapter.py:13-39`）。
  - 词典驱动别名边：根据 `synonyms_map` 主动生成 `ALIAS` 边并标注来源（`alias_source: synonyms_map`），便于图上解释（`xiyou/normalize_adapter.py:40-47`）。
  - 模板增强：`relations_plus.relation_types` 加入 `别名`，并补充 `玉皇大帝/玉皇上帝/昊天上帝/天帝 → 玉帝` 映射，提升连通性（`settings.yaml:...`）。

- 2025-11-28 v21
  - 新增自包含重建蓝图文档：`specs/一键重建蓝图.md`，在无现有实现的前提下，依据该文档即可复现“切分→抽取→归一与融合→入库”全流程。
  - 文档包含：配置要点、最小 `settings.yaml` 片段、统一数据结构、Neo4j模型与约束、关键函数伪代码、质量度量与手动一键重建路径。

## 待办清单
- 质量报告：按章节聚合差异与交集，输出评估摘要
- 依赖版本锁定与演示数据校验脚本
### 选择模式与触发逻辑（规范）
- `selection_mode: static | dynamic`
- `static`：始终使用 `prompts.selected` 对应模板，不进行切换。
- `dynamic`：在满足同时条件时切换模板：
  - 条件：章节长度 `> length_threshold` 且 对话比例 `> dialogue_ratio_threshold`
  - 切换目标：`dynamic.override_to`（默认 `events_relations`）
- 默认推荐：`selection_mode: static`，`length_threshold: 8000`，`dialogue_ratio_threshold: 0.50`

### 选择模式常见配置组合与使用建议
- 审阅期与基线评估（推荐）
  - 配置：`static` + `relations_plus`；阈值保留高位仅作参考
  - 适用：建立基线质量、便于人工审阅与对比
  - YAML：
    ```yaml
    prompts:
      selected: relations_plus
      selection_mode: static
      selectors:
        length_threshold: 8000
        dialogue_ratio_threshold: 0.50
    ```

 
- 事件导向抽取（对话密集章节）
  - 配置：`dynamic` + `override_to: events_relations`；降低阈值以更易触发
  - 适用：对话比例偏高的章节，补充事件结构
  - YAML：
    ```yaml
    prompts:
      selected: relations_plus
      selection_mode: dynamic
      dynamic:
        override_to: events_relations
      selectors:
        length_threshold: 6000
        dialogue_ratio_threshold: 0.40
    ```
- 长篇章节兼顾事件（保守触发）
  - 配置：`dynamic` + 高阈值；仅在超长且对话充分时切换
  - 适用：篇幅特别长的章节，避免过度切换
  - YAML：
    ```yaml
    prompts:
      selected: relations_plus
      selection_mode: dynamic
      dynamic:
        override_to: events_relations
      selectors:
        length_threshold: 12000
        dialogue_ratio_threshold: 0.45
    ```
- 保守策略（仅关系）
  - 配置：`static` + `relations_basic`
  - 适用：快速抽取核心关系、降低模型输出不确定性
  - YAML：
    ```yaml
    prompts:
      selected: relations_basic
      selection_mode: static
    ```
- 使用建议
  - 日志核对：查看 `template_selected` 是否与期望一致（`xiyou/batch_extractor.py:160-168`）。
  - 团队对齐：统一 `selection_mode` 与阈值，避免批量任务的评估口径不一致。
  - 逐步启用：先以 `static` 建立基线，再在样本章节上验证 `dynamic` 的收益与风险。

## 新增模块与函数签名
- `xiyou/normalize_adapter.py`
  - `parse_alias_rules(rules: list[str]) -> dict`
  - `canonical_original(name: str, alias: dict) -> str`
  - `canonical_norm(name: str, synonyms: dict, alias: dict) -> str`
  - `normalize_relations(obj: object, syn: dict, alias: dict) -> list[dict]`
  - `normalize_events(obj: object, syn: dict, alias: dict) -> list[dict]`
  - `collect_entities(relations: list[dict], entities_hint: list[dict], syn: dict, alias: dict) -> list[dict]`
  - `normalize_output(raw: object, tpl_id: str, synonyms_map: dict, alias_rules: list[str]) -> dict`
- `xiyou/ingest_neo4j.py`
  - `get_driver(settings: dict)`
  - `ensure_constraints(session)`
  - `neo4j_upsert(session, kg: dict, book_key: str, chapter_id: str)`
  - `ingest_results()`

## 使用示例（仅调用示例，不执行）
```python
from xiyou.normalize_adapter import normalize_output
from xiyou.config import load_settings, resolve_paths
import os, json

settings = load_settings()
p = resolve_paths(settings, 'xiyouji')
fp = os.path.join(p['results_dir'], 'result_001.json')
data = json.load(open(fp, 'r', encoding='utf-8'))
tpl_id = data.get('meta', {}).get('template_id', 'relations_plus')
tpl = next((t for t in settings.get('prompts', {}).get('templates', []) if t.get('id') == tpl_id), {})
syn = tpl.get('variables', {}).get('synonyms_map', {}) or {}
alias_rules = tpl.get('variables', {}).get('alias_rules', []) or []
kg = normalize_output(data, tpl_id, syn, alias_rules)
```

```python
from xiyou.ingest_neo4j import ingest_results

ingest_results()
```

## ALIAS 查询示例（Cypher）
```cypher
MATCH (a:Entity)-[r:RELATION {type:'ALIAS'}]->(b:Entity)
RETURN a.name AS alias, b.name AS canonical
LIMIT 20
```

```cypher
MATCH p=(a:Entity {name:$name})-[:RELATION {type:'ALIAS'}*0..3]->(b:Entity)
RETURN b.name AS canonical
LIMIT 1
```

```cypher
MATCH (c:Entity {name:$canonical})
OPTIONAL MATCH (a:Entity)-[:RELATION {type:'ALIAS'}]->(c)
WITH COLLECT(DISTINCT a.name) + [c.name] AS names
MATCH (h:Entity)-[r:RELATION]->(t:Entity)
WHERE h.name IN names OR t.name IN names
RETURN h.name, r.type, t.name
LIMIT 50
```
