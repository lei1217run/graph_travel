# 知识图谱提取与入库一键重建蓝图（v0.01）

## 目标
- 在无现有 `xiyou` 模块代码的前提下，大模型仅依据本文档即可复现：章节切分 → LLM 抽取 → 归一与融合 → Neo4j 入库；并以 `settings.yaml` 完成关键策略配置。
- 电子书地址：[https://www.gutenberg.org/cache/epub/23962/pg23962.txt](https://www.gutenberg.org/cache/epub/23962/pg23962.txt)

## 必要目录与命名规范
- 原文位置：`data/raw/{book_key}/{book_key}.txt`
- 章节输出：`data/chapters/{book_key}/<chapter_编号或标题>.txt`
- 结果输出：`data/results/{book_key}/result_%03d.json`（基线模板）；其它模板：`result_%03d__tpl-<template_id>.json`；可选模型后缀：`__model-<model_name>`。

## 设置文件（settings.yaml）
- 关键段落：
  - `llm`: `api_key/base_url/model_name/system_prompt/stream/thinking`
  - `corpora`: `mode/default/base_dir/items{key:name/folder/raw_file}`
  - `run`: `limit_count/timeout_ms`
  - `naming`: `mode`（`NUMBERING`/`TITLE_PREFIXED`）
  - `prompts`: `selected/selection_mode/selectors/dynamic/templates[].variables(synonyms_map/alias_rules)`
  - `relations`: `allowed/precedence/patterns/type_constraints/alias_relations`
  - `fusion`: `enabled/resolution_mode/group_by/key_format/confidence_merge/evidence_merge/conflict_resolution/chapter_strategy/keep_history`
  - `results`: `use_model_suffix/overwrite/basename_template_id`
  - `neo4j`: `uri/user/password`

### 最小示例片段
  - LLM_API_KEY：阿里云DashScope API密钥, 在环境变量或者.env文件中配置
  - NEO4J_PASSWORD：Neo4j数据库密码, 在环境变量或者.env文件中配置
  
```yaml
llm:
  api_key: ${LLM_API_KEY}
  base_url: https://dashscope.aliyuncs.com/compatible-mode/v1
  model_name: qwen-long
  system_prompt: 你是一个知识图谱结构化抽取助手。仅输出严格的JSON，禁止任何非JSON文本。
  stream: false
  thinking: false

corpora:
  mode: single
  default: xiyouji
  base_dir: data
  items:
    xiyouji:
      name: 西游记
      folder: 西游记
      raw_file: xiyouji.txt

run:
  limit_count: 2
  timeout_ms: 20000

naming:
  mode: TITLE_PREFIXED

results:
  use_model_suffix: false
  overwrite: true
  basename_template_id: relations_plus

relations:
  allowed: [师徒, 位于, 使用, 持有, 敌对, 别名, 姓氏, 法名, 封号, 本体, 源于, 亲属, 隶属]
  precedence: [姓氏, 法名, 封号, 别名]
  patterns:
    - relation: 姓氏
      include: ["姓", "其姓为", "复姓"]
      exclude: []
    - relation: 法名
      include: ["法名", "起法名", "赐法名"]
      exclude: []
    - relation: 封号
      include: ["封", "赐", "授", "册封", "加封"]
      exclude: []
    - relation: 别名
      include: ["又名", "别名", "称作", "称为", "自称"]
      exclude: []
  type_constraints:
    姓氏: ["Person-Text"]
    法名: ["Person-Text"]
    封号: ["Person-Title"]
  alias_relations: ["同义词","别名","同义词合并","别称","又名","称作","称为","自称"]

fusion:
  enabled: true
  resolution_mode: pre_ingest
  group_by: head_tail
  key_format: "{head}|{tail}|{relation}"
  confidence_merge: max
  evidence_merge: union
  conflict_resolution: precedence
  chapter_strategy: first
  keep_history: true

neo4j:
  uri: neo4j://127.0.0.1:7687
  user: neo4j
  password: ${NEO4J_PASSWORD}

prompts:
  selected: relations_plus
  selection_mode: static
  templates:
    - id: relations_plus
      description: 扩展关系范围并输出证据与置信度
      scope: plus
      entity_types: [Person, Location, Item, Spell, Organization, Deity]
      relation_types: [师徒, 敌对, 位于, 持有, 使用, 亲属, 隶属, 封号, 别名]
      instructions: |
        输出 JSON；每条关系包含 evidence(原文片段) 与 confidence(0-1)。当一证据支持多个关系时，分别输出多条记录。仅从闭集关系中选择；若不确定请忽略。
      output_schema: relation_with_meta
      variables:
        language: zh
        book: xiyouji
        synonyms_map:
          行者: 孙悟空
          大圣: 孙悟空
          美猴王: 孙悟空
          玄奘: 唐僧
          唐三藏: 唐僧
          老君: 太上老君
          玉皇大帝: 玉帝
          玉皇上帝: 玉帝
          昊天上帝: 玉帝
          天帝: 玉帝
        alias_rules:
          - strip:大圣
          - strip:行者
          - regex:(^“|”$)=
```

## 统一数据结构
- 目标统一结构：`{"entities": [...], "relations": [...], "events": [...], "meta": {...}}`
- 关系字段：`head/tail/relation/confidence?/evidence?/qualifiers?`
- 实体字段：`name`（规范名，来源于关系与实体提示）
- 事件字段：`event_type/time?/location?/participants{role→[entity]}?/evidence?/confidence?`

## Neo4j 模型与约束
- 节点：
  - `Entity {name}`；唯一键 `name`
  - `Event {event_type, book, chapter}`；唯一键 `(event_type, book, chapter)`
- 关系：
  - `(:Entity)-[:RELATION {type, confidence?, evidence?, qualifiers_json?, book, chapter}]->(:Entity)`
- 约束与索引：
  - `CREATE CONSTRAINT entity_name_unique IF NOT EXISTS FOR (e:Entity) REQUIRE e.name IS UNIQUE;`
  - `CREATE CONSTRAINT event_unique IF NOT EXISTS FOR (e:Event) REQUIRE (e.event_type, e.book, e.chapter) IS UNIQUE;`
  - `CREATE INDEX relation_type IF NOT EXISTS FOR ()-[r:RELATION]-() ON (r.type);`

## 核心流程（纯手动）
- 切分原文：读取 `raw_file` 生成章节文本到 `chapters_dir`，保持编号与标题前缀命名。
- 批量抽取：按模板构建 Prompt，调用 LLM 输出 JSON；保存 `result_%03d*.json` 并附带 `meta`。
- 归一与融合：
  - 名称归一：`synonyms_map + alias_rules` → 规范名；过滤类型枚举噪声。
  - 别名统一：`alias_relations` 中的关系统一转为 `ALIAS`；并根据 `synonyms_map` 主动生成 `ALIAS` 边，写入 `qualifiers.alias_source`。
  - 融合策略：按 `head-tail` 分组，使用 `precedence` 与 `confidence=max` 选择唯一关系；证据 `union` 合并；代表章节使用 `chapter_strategy:first`；所有参与章节保存在 `qualifiers.chapters`。
- 入库：幂等 `MERGE` 节点与关系；事件逐章写入，关系为融合结果写入代表章节。

## 关键函数蓝图（伪代码）
```python
def split_chapters(raw_file, chapters_dir):
    # 读取原文；按章节标题或编号切分；写入章节文件

def choose_template(text, settings):
    # static/dynamic 选择模板；返回模板对象

def build_prompt(template, text, settings):
    # 注入 entity_types/relation_types/闭集关系与优先级/同义词与别名规则/输出schema

def call_llm(prompt, settings):
    # 使用 system_prompt；可选 stream/thinking；仅返回 JSON 文本

def normalize_output(raw, tpl_id, synonyms_map, alias_rules, alias_relations):
    # 统一结构；归一名称；别名统一到 ALIAS；基于词典生成 ALIAS 边；收集实体与事件

def calibrate_relations(relations, settings):
    # 基于 patterns 的触发匹配，生成候选关系

def fuse_relations(relations, settings):
    # 按 head-tail 分组唯一选择；证据/置信度/章节合并

def neo4j_upsert(session, kg, book_key, chapter_id):
    # MERGE 节点；写入关系：type/confidence/evidence/qualifiers_json/book/chapter
```

## 质量度量与回路
- 指标：一致性率、冲突率、覆盖率、过滤比例、每章有效记录数。
- 策略迭代：依据指标调整 `relations.patterns/precedence/type_constraints` 与模板说明；词典持续扩充。

## 一键重启/重建路径（手动版）
- 检查并更新 `settings.yaml`（LLM/路径/模板/relations/fusion/neo4j）。
- 依次执行：切分 → 抽取 → 入库。
- 可选：通过对比接口审阅结果与指标；根据表现调整配置与词典。

## 说明
- 本蓝图不依赖现有代码文件；任何实现可遵循本文档的配置与流程达到同等效果。
- 优先使用闭集关系与融合策略确保稳定一致性；别名连通性依赖词典补齐与统一转储到 `ALIAS`。

